create table "public"."profiles" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "updated_at" timestamp with time zone not null default now(),
    "stripe_customer_id" text default ''::text,
    "is_subscribed" boolean default false,
    "subscription_id" text default ''::text,
    "subscription_ends_at" timestamp with time zone,
    "monthly_resumes_unlocked_count" bigint default '0'::bigint,
    "credits" bigint default '0'::bigint
);


alter table "public"."profiles" enable row level security;

create table "public"."resumes" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null default auth.uid(),
    "name" text,
    "data" jsonb,
    "updated_at" timestamp with time zone default now(),
    "paid_downloads_remaining" bigint not null default '0'::bigint,
    "is_unlocked_by_sub" boolean not null default false
);


alter table "public"."resumes" enable row level security;

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_stripe_customer_id_key ON public.profiles USING btree (stripe_customer_id);

CREATE UNIQUE INDEX profiles_subscription_id_key ON public.profiles USING btree (subscription_id);

CREATE UNIQUE INDEX resumes_pkey ON public.resumes USING btree (id);

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."resumes" add constraint "resumes_pkey" PRIMARY KEY using index "resumes_pkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_stripe_customer_id_key" UNIQUE using index "profiles_stripe_customer_id_key";

alter table "public"."profiles" add constraint "profiles_subscription_id_key" UNIQUE using index "profiles_subscription_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_user_credits(user_id_param uuid, credits_to_add integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE public.profiles
  SET credits = credits + credits_to_add
  WHERE id = user_id_param;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.decrement_user_credits(user_id_param uuid, credits_to_decrement integer)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  current_credits int;
  update_successful boolean := false;
BEGIN
  -- Select current credits FOR UPDATE to lock the row exclusively
  -- This prevents race conditions where two downloads might happen simultaneously
  SELECT credits INTO current_credits FROM public.profiles WHERE id = user_id_param FOR UPDATE;

  -- Check if user exists and has enough credits
  IF current_credits IS NOT NULL AND current_credits >= credits_to_decrement THEN
    -- Perform the decrement
    UPDATE public.profiles
    SET credits = credits - credits_to_decrement
    WHERE id = user_id_param;

    -- Check if the update affected exactly one row (it should have)
    GET DIAGNOSTICS update_successful = ROW_COUNT;
    -- ROW_COUNT might not be reliable in PL/pgSQL; alternative is checking FOUND
    RETURN FOUND; -- Returns true if the UPDATE statement modified a row
  ELSE
    RETURN false; -- User not found or insufficient credits
  END IF;

-- Optional: Basic exception handling
EXCEPTION
 WHEN OTHERS THEN
   RAISE WARNING 'Error in decrement_user_credits for user %: %', user_id_param, SQLERRM;
   RETURN false;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.handle_user_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- Delete all resumes owned by the user being deleted.
  delete from public.resumes
  where user_id = old.id;
  return old;
end;
$function$
;

create policy "Enable update access for users based on user_id"
on "public"."profiles"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = id))
with check ((( SELECT auth.uid() AS uid) = id));


create policy "Enable users to view their own data only"
on "public"."profiles"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "Allow users to update their own resumes"
on "public"."resumes"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Enable delete for users based on user_id"
on "public"."resumes"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable insert for authenticated users only"
on "public"."resumes"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable insert for users based on user_id"
on "public"."resumes"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable users to view their own data only"
on "public"."resumes"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();

CREATE TRIGGER on_user_deleted AFTER DELETE ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_user_delete();


